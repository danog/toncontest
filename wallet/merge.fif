#!/usr/bin/env -S fift -s
"TonUtil.fif" include

' constant : const
{ dup ."Loading order from file " type ."..." cr
  file>B B>boc
} : load-boc
{
  ."usage: " @' $0 type ." <input1> <input2> [<input3> ...] <output>" cr
  ."Merges multisig <inputx>.boc files and writes result to <output>.boc" cr 1 halt
} : usage
$# 3 < ' usage if

$# 1 - const input-len
1 { dup $() +".boc" swap 1+ } input-len times drop
input-len tuple const input-files

$# $() +".boc" const output-file

."Inspecting and merging " input-len . ."files..." cr
input-files explode 1- swap

load-boc
dup "inspect-lib.fif" include cr
message-hash const previous-hash
<s
  // External message
  7 u@+ nip
  8 i@+ nip
  256 u@+ nip
  Gram@+ nip
  2 u@+ nip

  // multiSigWrapper$0 signatures:(HashmapE 4 Signature) message:(WrappedMessage X) = MultiSigWrapper X;
  dict@+
  s>c const wrapped-message // Store message in const
  swap // put length on top, signatures right underneath

{ swap // Get filename, signatures right underneath
  load-boc
  dup "inspect-lib.fif" include cr
  message-hash previous-hash B= not abort"Hash mismatch!"
  <s
    // External message
    7 u@+ nip
    8 i@+ nip
    256 u@+ nip
    Gram@+ nip
    2 u@+ nip

    // multiSigWrapper$0 signatures:(HashmapE 4 Signature) message:(WrappedMessage X) = MultiSigWrapper X;
    dict@
  4 { drop s, -1 } dictmerge
} swap times

// Signatures are the only element on the stack
."Fianl message signed by the following keys: "
dup 4 { drop . ."- " -1 } dictforeach cr drop

<b 68 7 u, wallet_addr addr, 0 Gram, 0 2 u, swap dict, wrapped-message <s s, b>

2 boc+>B dup Bx. cr
output-file tuck B>file
."Saved new multisigned message to file " type cr
