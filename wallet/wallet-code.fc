;; Multisig wallet smart contract

;; Tuple manipulation primitives for integers
tuple tuple_set(tuple t, int index, int value) asm(t value index) "SETINDEXVARQ";
(tuple, ()) ~tuple_set(tuple t, int index, int value) asm(t value index) "SETINDEXVARQ";

;; Tuple manipulation primitives for cells
tuple tuple_setcell(tuple t, int index, cell value) asm(t value index) "SETINDEXVARQ";
(tuple, ()) ~tuple_setcell(tuple t, int index, cell value) asm(t value index) "SETINDEXVARQ";

int tuple_len(tuple t) asm "TLEN";

int udict_has?(cell dict, int key_len, int index) asm(index dict key_len) "DICTUGET" "SWAP" "DROP";

;; Cleanup expired partial orders
;; messages
(cell, ()) ~collect_garbage(cell messages) {
  var hash = -1;
  do {
    (hash, var cs, int ok) = messages.udict_get_next?(256, hash);
    if (ok) {

      ;; modeMessage$_ mode:uint8 body:^(Message X) = ModeMessage X;
      ;; wrappedMessage$_ expires_at:uint32 seqno:uint32 body:(ModeMessage X) = WrappedMessage X;
      ;; multiSigWrapperStorage$_ signatures:(HashmapE 4 Signature) message:(WrappedMessage X) = MultiSigWrapperStorage X;
      ;;
      ;; Skip signatures, check expiry
      ;;
      ;; expiry <= now
      if (cs.skip_dict().preload_uint(32) <= now()) {
        messages~udict_delete?(256, hash);
      }
    }
  } until (~ ok);

  return (messages, ());
}

() store_db(int seqno, cell keys, cell messages) {
  set_data(begin_cell().store_uint(seqno, 32).store_dict(keys).store_dict(messages).end_cell());
}

() recv_internal(slice in_msg) impure {
  ;; do nothing for internal messages
}

;; multiSigWrapper$0 keys_signatures:(HashmapE 4 Signature) message:(WrappedMessage X) = MultiSigWrapper X;
() recv_external(slice in_msg) impure {
  ;; Check if multiSigWrapper$0 or future unsupported protocol
  throw_if(32, in_msg~load_uint(1));

  ;; Check if is hme_empty$0 or hme_root$1
  ;; Throw if empty signature list
  throw_unless(33, in_msg.preload_uint(1));

  var signatures = in_msg~load_dict();
  slice message_data = in_msg;

  ;; wrappedMessage$_ expires_at:uint32 seqno:uint32 body:^(Message X) = WrappedMessage X;
  (int expires_at, int msg_seqno) = (message_data~load_uint(32), message_data~load_uint(32));
  ;; Message expired
  throw_if(34, expires_at <= now());

  ;; We will need the hash anyway
  int hash = slice_hash(in_msg);
  
  ;; storage$_ seqno:uint32 minSigs:(## 4) keys:[ ^PubKeys ] messages:(HashmapE 256 (StoredMessage X)) = Storage X;
  slice stored_data = get_data().begin_parse();
  (int stored_seqno, int min_sigs, var keys, var messages) = (stored_data~load_uint(32), stored_data~load_uint(4), stored_data~load_dict(), stored_data~load_dict());
  stored_data.end_parse();

  ;; This is a new message, so there will be no stored messages
  var storedMessageSignatures = new_dict();
  ;; If new message, check and increase seqno
  if (stored_seqno == msg_seqno) {
    stored_seqno += 1;
    
  ;; If old message, seqno WILL be different, check if exists in unsigned messages dict
  } else {
    var (storedMessage, ok) = messages.udict_get?(256, hash);
    ;; Throw if old message and doesn't exist in db
    throw_unless(35, ok);

    ;; multiSigWrapperStorage$_ signatures:(HashmapE 4 ^Signature) message:(WrappedMessage X) = MultiSigWrapperStorage X;
    ;;
    ;; Load signatures
    var storedMessageSignatures = storedMessage.preload_dict();
  }

  accept_message();
  message_data~touch();

  int idx = 0;
  do {
    (idx, var signature, int ok) = signatures.udict_get_next?(4, idx);
    if (ok) {
      (var public_key, ok) = keys.udict_get?(4, idx);
      throw_unless(36, ok);
      
      var slice_copy = signature;

      throw_unless(37, check_signature(hash, slice_copy, public_key.preload_uint(256)));

      storedMessageSignatures~udict_set_ref(4, idx, begin_cell().store_slice(signature).end_cell());
    }
  } until (~ ok);
  
  var (mode, message) = (message_data~load_uint(8), message_data~load_ref());
  message_data.end_parse();

  int count = 0;
  int sent = 0;
  int idx = 0;
  do {
    (idx, var signature, int ok) = storedMessageSignatures.udict_get_next?(4, idx);
    if (ok) {
      count += 1;
      if (count >= min_sigs) {
        send_raw_message(message, mode);
        messages~udict_delete?(256, hash);
        ok = 0;
      }
    }
  } until (~ ok);
  
  ;; modeMessage$_ mode:uint8 body:^(Message X) = ModeMessage X;
  ;; wrappedMessage$_ expires_at:uint32 seqno:uint32 body:(ModeMessage X) = WrappedMessage X;
  ;; multiSigWrapperStorage$_ signatures:(HashmapE 4 Signature) message:(WrappedMessage X) = MultiSigWrapperStorage X;
  ;;
  if (count < min_sigs) {
    messages~udict_set_ref(256, hash, begin_cell().store_dict(storedMessageSignatures).store_uint(expires_at, 32).store_uint(msg_seqno, 32).store_uint(mode, 8).store_ref(message).end_cell());
  }
  messages~collect_garbage();

  ;; storage$_ seqno:uint32 minSigs:(## 4) keys:[ ^PubKeys ] messages:(HashmapE 256 (Message X)) = Storage X;
  set_data(begin_cell().store_uint(stored_seqno + 1, 32).store_uint(min_sigs, 4).store_dict(keys).store_dict(messages).end_cell());
}

;; Get methods

int seqno() method_id {
  return get_data().begin_parse().preload_uint(32);
}

(int, int) getKey(int id) method_id {
  (var res, int ok) = get_data().begin_parse().skip_bits(36).preload_dict().udict_get?(4, id);
  if (~ ok) {
    return (ok, 0);
  }
  return (-1, res.preload_uint(256));
}
(int, int) getId(int key) method_id {
  var keys = get_data().begin_parse().skip_bits(36).preload_dict();
  int idx = 0;
  int ok = 0;
  do {
    (idx, var keyRead, ok) = keys.udict_get_next?(4, idx);
  } until ((~ ok) | (keyRead.preload_uint(256) == key));
  if (ok) {
    return (-1, idx);
  }
  return (0, 0);
}

(cell) getPartials() method_id {
  return get_data().begin_parse().skip_bits(36).skip_dict().preload_dict();
}
(cell) getPartialsById(int id) method_id {
  cell messages = get_data().begin_parse().skip_bits(36).skip_dict().preload_dict();
  cell messages_found = new_dict();

  int idx = 0;
  do {
    (idx, var message, int ok) = messages.udict_get_next?(256, idx);
    if (ok) {
      var contents = message.preload_ref();
      if (contents.begin_parse().preload_dict().udict_has?(4, id)) {
        messages_found~udict_set_ref(256, idx, contents);
      }
    }
  } until (~ ok);
  
  return messages_found;
}

(cell) getPartialsByKey(int key) method_id {
  (int ok, int id) = getId(key);
  ifnot (ok) {
    return new_dict();
  }
  return getPartialsById(id);
}
(cell) getPartialsByHash(int hash) method_id {
  return get_data().begin_parse().skip_bits(36).skip_dict().preload_dict().udict_get_ref(256, hash);
}