"Asm.fif" include
// automatically generated from `/home/daniil/repos/contest/lib/crypto/smartcont/stdlib.fc` `wallet-code.fc` 
PROGRAM{
  DECLPROC ~collect_garbage
  DECLPROC store_db
  DECLPROC recv_internal
  DECLPROC recv_external
  85143 DECLMETHOD seqno
  119659 DECLMETHOD getKey
  66593 DECLMETHOD getId
  124239 DECLMETHOD getPartials
  87848 DECLMETHOD getPartialsById
  125107 DECLMETHOD getPartialByKey
  100959 DECLMETHOD getPartialByHash
  ~collect_garbage PROC:<{
    -1 PUSHINT
    UNTIL:<{
      8 PUSHPOW2
      s2 PUSH
      SWAP
      DICTUGETNEXT
      NULLSWAPIFNOT
      NULLSWAPIFNOT
      DUP
      IF:<{
        s0 s2 XCHG
        SKIPDICT
        32 PLDU
        NOW
        LEQ
        IF:<{
          8 PUSHPOW2
          OVER
          s1 s4 XCHG
          s0 s4 XCHG
          DICTUDEL
          DROP
        }>ELSE<{
          s0 s2 XCHG
        }>
      }>ELSE<{
        s1 s3 XCHG
        s0 s2 XCHG
        DROP
      }>
      SWAP
      NOT
      s1 s2 XCHG
    }>
    DROP
  }>
  store_db PROC:<{
    NEWC
    s1 s3 XCHG
    32 STU
    STDICT
    STDICT
    ENDC
    c4 POP
  }>
  recv_internal PROC:<{
    DROP
  }>
  recv_external PROC:<{
    1 LDU
    SWAP
    32 THROWIF
    DUP
    1 PLDU
    33 THROWIFNOT
    LDDICT
    DUP
    32 LDU
    32 LDU
    NOW
    s1 s3 XCHG
    LEQ
    34 THROWIF
    s2 PUSH
    HASHSU
    c4 PUSH
    CTOS
    32 LDU
    4 LDU
    LDDICT
    LDDICT
    ENDS
    0 PUSHINT
    NEWDICT
    s5 PUSH
    SWAP
    s0 s8 XCHG
    EQUAL
    IF:<{
      s0 s4 XCHG
      INC
    }>ELSE<{
      DROP
      s7 POP
      8 PUSHPOW2
      s4 PUSH
      SWAP
      s8 PUSH
      SWAP
      DICTUGET
      NULLSWAPIFNOT
      35 THROWIFNOT
      4 LDU
      s0 s8 XCHG
      s1 s4 XCHG
      SWAP
    }>
    ACCEPT
    s0 s7 XCHG
    0 PUSHINT
    UNTIL:<{
      4 PUSHINT
      s11 PUSH
      SWAP
      DICTUGETNEXT
      NULLSWAPIFNOT
      NULLSWAPIFNOT
      DUP
      IF:<{
        DROP
        4 PUSHINT
        OVER
        SWAP
        s6 PUSH
        SWAP
        DICTUGET
        NULLSWAPIFNOT
        DUP
        36 THROWIFNOT
        s3 PUSH
        s0 s2 XCHG
        256 PLDU
        s10 PUSH
        s0 s2 XCHG
        s1 s3 XCHG
        s0 s3 XCHG
        CHKSIGNU
        37 THROWIFNOT
        4 PUSHINT
        s2 PUSH
        SWAP
        s11 PUSH
        SWAP
        DICTUGET
        NIP
        NOT
        IF:<{
          4 PUSHINT
          s2 s3 XCHG
          s3 PUSH
          s0 s2 XCHG
          s1 s11 XCHG
          s0 s11 XCHG
          DICTUSET
          s0 s6 XCHG
          INC
        }>ELSE<{
          s0 s9 XCHG
          s0 s7 XCHG
          s1 s2 XCHG
          SWAP
          DROP
        }>
      }>ELSE<{
        s0 s9 XCHG
        s0 s7 XCHG
        s1 s2 XCHG
        SWAP
        DROP
      }>
      s0 s8 XCHG
      NOT
      s6 s8 XCHG
    }>
    DROP
    s9 POP
    s0 s8 XCHG
    8 LDU
    LDREF
    ENDS
    s4 PUSH
    s4 PUSH
    GEQ
    IF:<{
      s4 POP
      s5 POP
      s6 POP
      s0 s3 XCHG
      SENDRAWMSG
      8 PUSHPOW2
      s1 s2 XCHG
      s1 s5 XCHG
      DICTUDEL
      DROP
    }>ELSE<{
      DROP
      DROP
      4 PUSHINT
      NEWC
      s1 s2 XCHG
      SWAP
      s0 s4 XCHG
      STUX
      s1 s4 XCHG
      STDICT
      SWAP
      s0 s5 XCHG
      STSLICER
      8 PUSHPOW2
      s1 s3 XCHG
      s1 s6 XCHG
      DICTUSETB
    }>
    ~collect_garbage CALLDICT
    SWAP
    INC
    NEWC
    32 STU
    s1 s3 XCHG
    4 STU
    STDICT
    STDICT
    ENDC
    c4 POP
  }>
  seqno PROC:<{
    c4 PUSH
    CTOS
    32 PLDU
  }>
  getKey PROC:<{
    c4 PUSH
    CTOS
    40 PUSHINT
    SDSKIPFIRST
    PLDDICT
    4 PUSHINT
    DICTUGET
    NULLSWAPIFNOT
    DUP
    NOT
    IFJMP:<{
      NIP
      0 PUSHINT
    }>
    DROP
    -1 PUSHINT
    SWAP
    256 PLDU
  }>
  getId PROC:<{
    c4 PUSH
    CTOS
    40 PUSHINT
    SDSKIPFIRST
    PLDDICT
    0 PUSHINT
    DUP
    UNTIL:<{
      DROP
      4 PUSHINT
      s2 PUSH
      SWAP
      DICTUGETNEXT
      NULLSWAPIFNOT
      NULLSWAPIFNOT
      DUP
      NOT
      s0 s3 XCHG
      256 PLDU
      s5 PUSH
      EQUAL
      s1 s3 XCHG
      OR
      s1 s2 XCHG
    }>
    s2 POP
    s2 POP
    IFJMP:<{
      -1 PUSHINT
      SWAP
    }>
    DROP
    0 PUSHINT
    DUP
  }>
  getPartials PROC:<{
    c4 PUSH
    CTOS
    40 PUSHINT
    SDSKIPFIRST
    SKIPDICT
    PLDDICT
  }>
  getPartialsById PROC:<{
    c4 PUSH
    CTOS
    40 PUSHINT
    SDSKIPFIRST
    SKIPDICT
    PLDDICT
    NEWDICT
    0 PUSHINT
    UNTIL:<{
      8 PUSHPOW2
      s3 PUSH
      SWAP
      DICTUGETNEXT
      NULLSWAPIFNOT
      NULLSWAPIFNOT
      DUP
      IF:<{
        s0 s2 XCHG
        PLDREF
        DUP
        CTOS
        PLDDICT
        4 PUSHINT
        s7 PUSH
        s0 s2 XCHG
        SWAP
        DICTUGET
        NIP
        IF:<{
          8 PUSHPOW2
          s1 s2 XCHG
          OVER
          s1 s5 XCHG
          s0 s5 XCHG
          DICTUSETREF
        }>ELSE<{
          s1 s3 XCHG
          DROP
        }>
      }>ELSE<{
        s1 s3 XCHG
        s0 s2 XCHG
        DROP
      }>
      SWAP
      NOT
      s1 s2 XCHG
    }>
    DROP
    NIP
    NIP
  }>
  getPartialByKey PROC:<{
    getId CALLDICT
    SWAP
    IFNOTJMP:<{
      DROP
      NEWDICT
    }>
    getPartialsById CALLDICT
  }>
  getPartialByHash PROC:<{
    c4 PUSH
    CTOS
    40 PUSHINT
    SDSKIPFIRST
    SKIPDICT
    PLDDICT
    8 PUSHPOW2
    DICTUGETOPTREF
  }>
}END>c
