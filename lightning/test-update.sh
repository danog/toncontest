
#!/bin/bash -e
# Define some helper functions
chr() { [ "$1" -lt 256 ] || return 1; printf "\\$(printf '%03o' "$1")"; }
ord() { LC_CTYPE=C printf '%d' "'$1"; }

cd tests
{
    # Sign previous simple wallet query (a, b) with key c (a, b, c)
    fift -s ../sign.fif b abc c 2

    # Update the wallet using code from wallet-code-update.fif,
    # also substituting the 10 keys with only 3 and setting k to 3
    fift -s ../wallet-update.fif pony code-update-a 1 3 3 0 a b c

    # Sign the query using all keys separately, creating eight more boc files, each signed by two keys only (0 and 1..9)
    for f in {1..9}; do fift -s ../sign.fif code-update-a code-update-$(chr $((97+f))) $(chr $((97+f))) $f;done

    # Merge all queries
    fift -s ../merge.fif code-update-{a..j} code-update-merge

    # Inspect queries
    fift -s ../inspect.fif merge

    # Finally run the generated files in the VM
    #
    # First init VM with constructor message
    # Then load first file with only two signatures by key a, b (0, 1)
    # Then load wallet code update (0)
    # Run seqno get-method
    # Run getPartialsByKeyId get-method
    # Load wallet code update with all signatures (and UPDATE CODE)
    # Run getPartialsByKeyId get-method
    # Finally load file with three signatures by keys a, b, c (0, 1, 2)
    #
    # The latter will actually send the message, since now only three signatures are required to send a message (but the wallet code update was signed by all 10)
    # This will not actually update the code, since there is no way (yet) to get a list of output actions generated by the TON VM from fift,
    # however the message **will be sent** since the minSig and keys fields in persistent storage will be updated.
    #
    fift -s ../test.fif \
        pony-create \
        b -1 \
        code-update-a -1 \
        0 85143 \
        0 113609 \
        code-update-merge -1 \
        abc -1
} 2>&1 | less -R
