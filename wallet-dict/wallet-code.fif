"Asm.fif" include
// automatically generated from `/home/daniil/repos/contest/lib/crypto/smartcont/stdlib.fc` `wallet-code.fc` 
PROGRAM{
  DECLPROC ~collect_garbage
  DECLPROC ~load_keys
  DECLPROC preload_keys
  DECLPROC skip_keys
  DECLPROC store_keys
  DECLPROC store_db
  DECLPROC recv_internal
  DECLPROC recv_external
  85143 DECLMETHOD seqno
  119659 DECLMETHOD getKey
  66593 DECLMETHOD getId
  124239 DECLMETHOD getPartials
  87848 DECLMETHOD getPartialsById
  ~collect_garbage PROC:<{
    -1 PUSHINT
    UNTIL:<{
      OVER
      8 PUSHPOW2
      DICTUGETNEXT
      NULLSWAPIFNOT
      NULLSWAPIFNOT
      DUP
      IF:<{
        s0 s2 XCHG
        SKIPDICT
        32 PLDU
        NOW
        LEQ
        IF:<{
          8 PUSHPOW2
          s1 s3 s3 PUXC2
          DICTUDEL
          DROP
        }>ELSE<{
          s0 s2 XCHG
        }>
      }>ELSE<{
        2SWAP
        DROP
      }>
      SWAP
      NOT
      s1 s2 XCHG
    }>
    DROP
  }>
  ~load_keys PROC:<{
    4 LDU
    0 PUSHINT
    PUSHNULL
    PUSHNULL
    s0 s3 XCHG
    LDREF
    s4 s1 XCPU
    0 PUSHINT
    SETINDEXVARQ
    SWAP
    CTOS
    UNTIL:<{
      s3 PUSH
      3 PUSHINT
      MOD
      0 EQINT
      IF:<{
        s3 PUSH
        9 LESSINT
        s4 PUSH
        0 GTINT
        AND
        IF:<{
          DUP
          ENDS
          s0 s4 XCHG
          LDREF
          s4 PUSH
          3 PUSHINT
          DIV
          s3 s2 s(-1) XCPUXC
          SETINDEXVARQ
          NIP
        }>ELSE<{
          DUP
          PLDREF
          CTOS
          SWAP
          ENDS
          s4 s4 XCHG2
        }>
      }>ELSE<{
        s4 s4 XCHG2
      }>
      s4 PUSH
      256 PLDU
      s3 s0 s4 XC2PU
      SETINDEXVARQ
      s0 s3 XCHG
      INC
      s0 s5 PUSH2
      EQUAL
      s5 s4 s0 XCHG3
      s3 s3 s0 XCHG3
    }>
    s3 POP
    s4 POP
    SWAP
    ENDS
    ROT
  }>
  preload_keys PROC:<{
    4 LDU
    0 PUSHINT
    PUSHNULL
    s0 s2 XCHG
    LDREF
    DROP
    CTOS
    UNTIL:<{
      OVER
      3 PUSHINT
      MOD
      0 EQINT
      IF:<{
        OVER
        9 LESSINT
        s2 PUSH
        0 GTINT
        AND
        IF:<{
        }>ELSE<{
        }>
      }>
      256 LDU
      s3 s3 s2 XC2PU
      SETINDEXVARQ
      SWAP
      INC
      s0 s3 PUSH2
      EQUAL
      s1 s3 s0 XCHG3
    }>
    s2 s3 XCHG
    3 BLKDROP
  }>
  skip_keys PROC:<{
    4 LDU
    SWAP
    3 PUSHINT
    DIV
    3 PUSHINT
    MIN
    UNTIL:<{
      SWAP
      LDREF
      NIP
      OVER
      0 EQINT
      s1 s2 XCHG
    }>
    DROP
  }>
  store_keys PROC:<{
    4 PUSHINT
    2SWAP
    STUX
    OVER
    TLEN
    s2 POP
    0 PUSHINT
    UNTIL:<{
      INC
      s0 s2 PUSH2
      EQUAL
    }>
    DROP
    NIP
  }>
  store_db PROC:<{
    NEWC
    s1 s3 XCHG
    32 STU
    STDICT
    STDICT
    ENDC
    c4 POP
  }>
  recv_internal PROC:<{
    DROP
  }>
  recv_external PROC:<{
    1 LDU
    SWAP
    32 THROWIFNOT
    DUP
    1 PLDU
    33 THROWIFNOT
    LDDICT
    DUP
    32 LDU
    32 LDU
    s2 PUSH
    NOW
    LEQ
    34 THROWIF
    s0 s3 XCHG
    HASHSU
    c4 PUSH
    CTOS
    32 LDU
    4 LDU
    ~load_keys CALLDICT
    s0 s2 XCHG
    LDDICT
    ENDS
    NEWDICT
    s5 s7 PUSH2
    EQUAL
    IF:<{
      s0 s5 XCHG
      INC
    }>ELSE<{
      s6 s1 PUSH2
      8 PUSHPOW2
      DICTUGET
      NULLSWAPIFNOT
      35 THROWIFNOT
      LDREF
      NIP
      ENDS
      s0 s5 XCHG
    }>
    ACCEPT
    s0 s9 XCHG
    -1 PUSHINT
    UNTIL:<{
      s11 PUSH
      4 PUSHINT
      DICTUGETNEXT
      NULLSWAPIFNOT
      NULLSWAPIFNOT
      DUP
      IF:<{
        s5 s1 PUSH2
        INDEXVAR
        s0 s3 XCHG
        LDREF
        DROP
        DUP
        CTOS
        DUP
        ENDS
        s11 s0 s4 PUXC2
        CHKSIGNU
        37 THROWIFNOT
        s1 s2 XCHG
        4 PUSHINT
        s3 s9 s9 PUXC2
        DICTUSETREF
      }>ELSE<{
        s1 s8 s8 XCHG3
        DROP
      }>
      s0 s7 XCHG
      NOT
    }>
    DROP
    s10 POP
    s0 s9 XCHG
    8 LDU
    LDREF
    ENDS
    0 PUSHINT
    -1 PUSHINT
    UNTIL:<{
      s7 PUSH
      4 PUSHINT
      DICTUGETNEXT
      NULLSWAPIFNOT
      NULLSWAPIFNOT
      s2 POP
      OVER
      IF:<{
        s0 s2 XCHG
        INC
        s0 s7 PUSH2
        GEQ
        IF:<{
          NIP
          s2 s3 PUSH2
          SENDRAWMSG
          8 PUSHPOW2
          s9 s13 s13 PUXC2
          DICTUDEL
          DROP
          0 PUSHINT
        }>ELSE<{
          s13 s13 XCHG2
        }>
      }>ELSE<{
        s0 s13 s13 XCHG3
      }>
      NOT
      s13 s13 s0 XCHG3
    }>
    DROP
    s5 PUSH
    LESS
    IF:<{
      NEWC
      s1 s6 XCHG
      STDICT
      s1 s8 XCHG
      32 STU
      s1 s6 XCHG
      32 STU
      s1 s6 XCHG
      8 STU
      s1 s2 XCHG
      STREF
      ENDC
      s0 s0 s6 XCHG3
      8 PUSHPOW2
      DICTUSETREF
    }>ELSE<{
      s4 s10 XCHG
      s3 s8 XCHG
      s2 s7 XCHG
      s4 s6 XCHG
      6 BLKDROP
    }>
    ~collect_garbage CALLDICT
    s0 s3 XCHG
    INC
    NEWC
    32 STU
    s1 s4 XCHG
    4 STU
    s0 s3 XCHG
    TLEN
    s2 s3 XCHG
    SWAP
    store_keys CALLDICT
    STDICT
    ENDC
    c4 POP
  }>
  seqno PROC:<{
    c4 PUSH
    CTOS
    32 PLDU
  }>
  getKey PROC:<{
    c4 PUSH
    CTOS
    36 PUSHINT
    SDSKIPFIRST
    preload_keys CALLDICT
    SWAP
    INDEXVAR
    DUP
    ISNULL
    IFJMP:<{
      DROP
      0 PUSHINT
      DUP
    }>
    -1 PUSHINT
    SWAP
  }>
  getId PROC:<{
    c4 PUSH
    CTOS
    36 PUSHINT
    SDSKIPFIRST
    preload_keys CALLDICT
    0 PUSHINT
    OVER
    TLEN
    UNTIL:<{
      s2 PUSH
      0 INDEX
      s4 PUSH
      EQUAL
      IFJMP:<{
        s1 s3 XCHG
        3 BLKDROP
        -1 PUSHINT
        SWAP
      }>
      2DUP
      EQUAL
    }>
    4 BLKDROP
    0 PUSHINT
    DUP
  }>
  getPartials PROC:<{
    c4 PUSH
    CTOS
    36 PUSHINT
    SDSKIPFIRST
    skip_keys CALLDICT
    PLDDICT
  }>
  getPartialsById PROC:<{
    DROP
    c4 PUSH
    CTOS
    36 PUSHINT
    SDSKIPFIRST
    skip_keys CALLDICT
    PLDDICT
  }>
}END>c
